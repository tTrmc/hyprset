"""
Hyprland configuration file parser.

Handles parsing of Hyprland configuration files including:
- Variable definitions ($var = value)
- Section blocks (section { ... })
- Inline settings (section::option = value)  
- Comments (# comment, ## escaped #)
- Bezier curves, colors, and other data types
"""

import re
import os
from typing import Dict, List, Any, Optional, Union
from pathlib import Path
from .data_types import Setting, Color, Bezier, Gradient


class HyprlandConfigParser:
    """Parser for Hyprland configuration files."""
    
    def __init__(self, config_path: Optional[str] = None):
        self.config_path = config_path or self._get_default_config_path()
        self.variables: Dict[str, str] = {}
        self.settings: Dict[str, Setting] = {}
        self.beziers: Dict[str, Bezier] = {}
        self.raw_lines: List[str] = []
        
    def _get_default_config_path(self) -> str:
        """Get the default Hyprland config path."""
        config_home = os.environ.get('XDG_CONFIG_HOME', os.path.expanduser('~/.config'))
        return os.path.join(config_home, 'hypr', 'hyprland.conf')
    
    def load(self) -> bool:
        """Load and parse the configuration file."""
        try:
            if not os.path.exists(self.config_path):
                # Create default config if it doesn't exist
                self._create_default_config()
                return True
                
            with open(self.config_path, 'r', encoding='utf-8') as f:
                self.raw_lines = f.readlines()
            
            self._parse_config()
            return True
            
        except FileNotFoundError:
            print("Warning: Hyprland config file not found, creating default configuration")
            return True
        except PermissionError:
            print("Error: Permission denied when reading Hyprland config file")
            return False
        except UnicodeDecodeError as e:
            print(f"Error: Config file contains invalid characters: {e}")
            return False
        except Exception as e:
            print(f"Error: Failed to load Hyprland configuration: {e}")
            return False
    
    def save(self) -> bool:
        """Save the current configuration to file."""
        try:
            # Create backup
            if os.path.exists(self.config_path):
                backup_path = f"{self.config_path}.backup"
                with open(self.config_path, 'r') as src, open(backup_path, 'w') as dst:
                    dst.write(src.read())
            
            # Generate new config content
            config_content = self._generate_config_content()
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            
            # Write to file
            with open(self.config_path, 'w', encoding='utf-8') as f:
                f.write(config_content)
            
            return True
            
        except PermissionError:
            print("Error: Permission denied when saving Hyprland config file")
            return False
        except OSError as e:
            print(f"Error: Failed to write config file: {e}")
            return False
        except Exception as e:
            print(f"Error: Unexpected error while saving configuration: {e}")
            return False
    
    def _create_default_config(self):
        """Create a minimal default configuration."""
        default_config = '''# Hyprland configuration file
# Generated by hyprset

# Basic settings
general {
    gaps_in = 5
    gaps_out = 10
    border_size = 2
    col.active_border = rgba(33ccffee)
    col.inactive_border = rgba(595959aa)
    layout = dwindle
}

decoration {
    rounding = 10
    active_opacity = 1.0
    inactive_opacity = 1.0
    drop_shadow = yes
    shadow_range = 4
    shadow_render_power = 3
    col.shadow = rgba(1a1a1aee)
}

animations {
    enabled = yes
    bezier = myBezier, 0.05, 0.9, 0.1, 1.05
    animation = windows, 1, 7, myBezier
    animation = windowsOut, 1, 7, default, popin 80%
    animation = border, 1, 10, default
    animation = borderangle, 1, 8, default
    animation = fade, 1, 7, default
    animation = workspaces, 1, 6, default
}
'''
        os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
        with open(self.config_path, 'w', encoding='utf-8') as f:
            f.write(default_config)
        
        # Parse the default config
        self.raw_lines = default_config.split('\n')
        self._parse_config()
    
    def _parse_config(self):
        """Parse the loaded configuration lines."""
        current_section = ""
        section_stack = []
        
        for line_num, raw_line in enumerate(self.raw_lines):
            line = self._clean_line(raw_line)
            
            if not line:  # Skip empty lines
                continue
                
            # Handle section opening
            if line.endswith('{'):
                section_name = line[:-1].strip()
                section_stack.append(section_name)
                current_section = ':'.join(section_stack)
                continue
            
            # Handle section closing
            if line == '}':
                if section_stack:
                    section_stack.pop()
                current_section = ':'.join(section_stack)
                continue
            
            # Handle variable definitions
            if line.startswith('$'):
                self._parse_variable(line)
                continue
            
            # Handle bezier definitions
            if line.startswith('bezier'):
                self._parse_bezier(line)
                continue
            
            # Handle regular settings
            if '=' in line:
                self._parse_setting(line, current_section)
    
    def _clean_line(self, raw_line: str) -> str:
        """Clean a line by removing comments and whitespace."""
        line = raw_line.strip()
        
        # Handle comments (# but not ##)
        if '#' in line:
            # Find comment position, but ignore ## (escaped #)
            pos = 0
            while pos < len(line):
                if line[pos:pos+2] == '##':
                    pos += 2
                elif line[pos] == '#':
                    line = line[:pos].strip()
                    break
                else:
                    pos += 1
        
        # Replace escaped ## with single #
        line = line.replace('##', '#')
        
        return line
    
    def _parse_variable(self, line: str):
        """Parse a variable definition."""
        if '=' in line:
            parts = line.split('=', 1)
            var_name = parts[0].strip()
            var_value = parts[1].strip()
            self.variables[var_name] = var_value
    
    def _parse_bezier(self, line: str):
        """Parse a bezier curve definition."""
        try:
            bezier = Bezier.from_config_string(line)
            self.beziers[bezier.name] = bezier
        except ValueError as e:
            print(f"Warning: Invalid bezier curve format in config: {e}")
    
    def _parse_setting(self, line: str, current_section: str):
        """Parse a regular setting line."""
        if '=' not in line:
            return
            
        parts = line.split('=', 1)
        key = parts[0].strip()
        value = parts[1].strip()
        
        # Handle inline section syntax (section::option)
        if '::' in key:
            section_path = key.replace('::', ':')
        else:
            section_path = f"{current_section}:{key}" if current_section else key
        
        # Parse the value based on its type
        parsed_value = self._parse_value(value)
        
        # Store the setting
        self.settings[section_path] = Setting(section_path, parsed_value)
    
    def _parse_value(self, value: str) -> Any:
        """Parse a configuration value to the appropriate Python type."""
        value = value.strip()
        
        # Handle variable substitution
        if value.startswith('$'):
            return self.variables.get(value, value)
        
        # Handle colors
        if value.startswith('rgba(') and value.endswith(')'):
            try:
                return Color.from_rgba_string(value)
            except (ValueError, TypeError):
                pass  # Invalid rgba format, continue parsing
        elif value.startswith('#') or (len(value) == 6 and all(c in '0123456789abcdefABCDEF' for c in value)):
            try:
                return Color.from_hex(value)
            except (ValueError, TypeError):
                pass  # Invalid hex format, continue parsing
        
        # Handle numbers
        try:
            if '.' in value:
                return float(value)
            else:
                return int(value)
        except ValueError:
            pass
        
        # Handle booleans
        if value.lower() in ('true', 'yes', '1', 'on'):
            return True
        elif value.lower() in ('false', 'no', '0', 'off'):
            return False
        
        # Return as string if no other type matches
        return value
    
    def _generate_config_content(self) -> str:
        """Generate configuration file content from current settings."""
        lines = []
        
        # Add header comment
        lines.append("# Hyprland configuration file")
        lines.append("# Modified by hyprset")
        lines.append("")
        
        # Add variables
        if self.variables:
            lines.append("# Variables")
            for var_name, var_value in self.variables.items():
                lines.append(f"{var_name} = {var_value}")
            lines.append("")
        
        # Group settings by section
        sections = {}
        for path, setting in self.settings.items():
            parts = path.split(':')
            if len(parts) >= 2:
                section = parts[0]
                option = ':'.join(parts[1:])
                if section not in sections:
                    sections[section] = {}
                sections[section][option] = setting.value
            else:
                # Top-level setting
                if 'general' not in sections:
                    sections['general'] = {}
                sections['general'][path] = setting.value
        
        # Write sections
        for section_name, options in sections.items():
            lines.append(f"{section_name} {{")
            for option, value in options.items():
                lines.append(f"    {option} = {self._format_value(value)}")
            lines.append("}")
            lines.append("")
        
        # Add beziers
        if self.beziers:
            lines.append("# Bezier curves")
            for bezier in self.beziers.values():
                lines.append(bezier.to_config_string())
            lines.append("")
        
        return '\n'.join(lines)
    
    def _format_value(self, value: Any) -> str:
        """Format a value for writing to config file."""
        if isinstance(value, Color):
            return f"rgba({value.r:02x}{value.g:02x}{value.b:02x}{value.a:02x})"
        elif isinstance(value, bool):
            return "yes" if value else "no"
        elif isinstance(value, (int, float)):
            return str(value)
        else:
            return str(value)